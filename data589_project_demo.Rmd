---
title: "Untitled"
output: html_document
date: "2025-03-30"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(sf)
library(ggplot2)
library(dplyr) # Load dplyr for filtering etc.
library(rnaturalearth)

library(raster)
library(spatstat)
library(viridis)
library(RColorBrewer)

#library(mapview)
```

```{r}
# 1. Load the rgbif library
# install.packages("rgbif") # Run this if you haven't installed it yet
library(rgbif)

# 2. Find the GBIF Taxon Key for Canis lupus
species_key <- name_backbone(name = "Canis lupus", rank = "species")$usageKey

# 3. Check if the key was found
if (is.null(species_key)) {
  stop("Could not find GBIF taxon key for Canis lupus. Check spelling or GBIF status.")
} else {
  print(paste("Found GBIF key for Canis lupus:", species_key))
}
```


```{r}
# 4. Define the geographic filters
  # GBIF uses ISO 3166-1 alpha-2 country codes (CA for Canada)
  target_country <- "CA"
  # Use the full province name as GBIF generally expects
  target_province <- "British Columbia"

  # 5. Perform the occ_search with geographic filters
  print(paste("Searching for Canis lupus occurrences in", target_province, ",", target_country, "..."))
```

```{r}
# Increase the limit if you expect more records, but be mindful of occ_search limitations.
  # hasCoordinate = TRUE is often useful for mapping/spatial analysis.
  # return = "data" gives you the data frame directly.
  search_result_list <- occ_search(
    taxonKey = species_key,
    country = target_country,
    stateProvince = target_province,
    limit = 1000000,        # Adjust this limit based on expected results / needs
    hasCoordinate = TRUE, # Optional: Get only records with coordinates
    # You could add other filters like year, basisOfRecord etc.
    # basisOfRecord = "OBSERVATION" # Example: only observations
    # year = "2020,2023"            # Example: only from 2020-2023
  )
```


```{r}
# --- Extract the data frame from the returned list ---
# Check if the search returned results and specifically if the 'data' element exists
if (!is.null(search_result_list) && !is.null(search_result_list$data)) {
    lupus_bc_search_df <- search_result_list$data
    print(paste("Retrieved", nrow(lupus_bc_search_df), "records via occ_search."))
    print("First few records:")
    print(head(lupus_bc_search_df))
    dim(lupus_bc_search_df)

    # Now you can proceed with creating the sf object and further analysis
    # lupus_bc_sf <- st_as_sf(lupus_bc_search_df, ...) # etc.

} else if (!is.null(search_result_list) && is.null(search_result_list$data)) {
    print("Search successful, but no matching occurrence data found in the 'data' element.")
    # You can inspect other parts of the list for clues:
    # print(search_result_list$meta)
} else {
    print("Search failed or returned NULL. Check parameters or connection.")
}
```
```{r}
# Check column names
colnames(lupus_bc_search_df)

# Look at the first few rows of coordinate columns (replace names if different)
head(lupus_bc_search_df[, c("decimalLongitude", "decimalLatitude")])

# Check for missing coordinate data
sum(is.na(lupus_bc_search_df$decimalLongitude))
sum(is.na(lupus_bc_search_df$decimalLatitude))
```

```{r}
# Remove rows with missing coordinates first (important!)
lupus_bc_search_df <- lupus_bc_search_df %>%
  filter(!is.na(decimalLongitude) & !is.na(decimalLatitude))

# Convert to an sf object
# Ensure coords are in the order: X (Longitude), Y (Latitude)
# GBIF data typically uses WGS84 (EPSG:4326) coordinate reference system (CRS)
lupus_bc_search_df <- st_as_sf(lupus_bc_search_df,
                       coords = c("decimalLongitude", "decimalLatitude"),
                       crs = 4326, # WGS84 CRS
                       remove = FALSE) # Keep original coordinate columns if desired

# Check the result
print(lupus_bc_search_df)
class(lupus_bc_search_df) # Should include "sf" and "data.frame"
st_crs(lupus_bc_search_df) # Verify the CRS is set correctly
```

```{r}
 # Simple plot using sf's default plot method
plot(st_geometry(lupus_bc_search_df), pch = ".", main = "Canis lupus Occurrences in BC (WGS84)")

# Nicer plot using ggplot2
ggplot() +
  geom_sf(data = lupus_bc_search_df, size = 0.5, alpha = 0.7) + # Plot the points
  labs(title = "Canis lupus Occurrences in BC",
       x = "Longitude", y = "Latitude") +
  theme_minimal() # Use a minimal theme
```

```{r}
# Load British Columbia shapefile from rnaturalearth
bc_shapefile <- ne_states(country = "Canada", returnclass = "sf") %>%
  filter(name == "British Columbia")

# Plot Gray Wolf occurrences with BC map overlay
ggplot() +
  # Plot the BC boundary (light gray fill)
  geom_sf(data = bc_shapefile, fill = "lightgray", color = "black") +
  # Plot Gray Wolf occurrence points
  geom_point(data = lupus_bc_search_df, aes(x = decimalLongitude, y = decimalLatitude),
             alpha = 0.5, color = "blue") +
  labs(title = "Gray Wolf Occurrences in British Columbia",
       x = "Longitude", y = "Latitude") +
  theme_minimal() +
  theme(legend.position = "none")  # Remove legend if not needed
```


```{r}
load("BC_Covariates.Rda")
```

```{r}
proj_Args <- DATA$Window@proj4string@projargs

print(proj_Args)
```

```{r}
target_crs <- st_crs(DATA$Window)

print(target_crs)
```


```{r}
# Step 3: TRANSFORM the coordinates - This CHANGES the numbers
lupus_bc_transformed <- st_transform(lupus_bc_search_df, crs = target_crs)

```

```{r}
# Check the CRS of the transformed object
print(st_crs(lupus_bc_transformed))
```




```{r}
  # Plot the geometry of the transformed points
  plot(st_geometry(lupus_bc_transformed), pch = '.') # pch='.' is good for many points
  
  # Optional: Plot your original window data first, then add points
  # Make sure DATA$Window is also an sf object
  window_sf <- st_as_sf(DATA$Window)
  plot(st_geometry(window_sf), border = 'blue') # Plot window outline
  plot(st_geometry(lupus_bc_transformed), pch = '.', add = TRUE, col = 'red') # Add points
```


```{r}
# Plot the SpatialPolygons object
plot(DATA$Window)

# Add customization if desired
plot(DATA$Window,
     col = "lightblue",      # Fill color
     border = "darkblue",    # Border color
     main = "Study Area Window", # Title
     xlab = "Easting (m)",     # X-axis label (adjust if units differ)
     ylab = "Northing (m)")    # Y-axis label (adjust if units differ)
```


```{r}
# --- Option 2a: Convert to sf and use sf's base plot ---
# Convert the sp object to an sf object
window_sf <- st_as_sf(DATA$Window)

# Plot using sf's plot method (often adds graticules/axes automatically)
plot(window_sf)

# Plot just the geometry
plot(st_geometry(window_sf), col = "lightgreen", border = "darkgreen")

# --- Option 2b: Convert to sf and use ggplot2 ---
# install.packages("ggplot2") # If not already installed
library(ggplot2)

# Assuming you converted using window_sf <- st_as_sf(DATA$Window)

ggplot() +
  geom_sf(data = window_sf, fill = "grey", color = "black") + # Plot the sf object
  theme_minimal() +                                         # Apply a theme
  ggtitle("Study Area Window") +
  xlab("Easting (m)") + # Adjust labels as needed based on CRS
  ylab("Northing (m)")
```

```{r}
# Convert DATA$Window (sp object) to an sf object
window_sf <- st_as_sf(DATA$Window)

# --- Check CRSs match (Important!) ---
# This should return TRUE if the transformation worked and window was read correctly
print(paste("CRSs match:", identical(st_crs(window_sf), st_crs(lupus_bc_transformed))))

# --- Plotting ---
# 1. Plot the base layer (window polygon)
#    Use st_geometry() if you only want the shape, not axes based on attributes
plot(st_geometry(window_sf),
     col = "grey85",          # Set fill color for the polygon
     border = "grey40",      # Set border color for the polygon
     main = "Lupus Occurrences in Study Window", # Title
     xlab = "Easting (m)",    # Adjust axis labels if needed
     ylab = "Northing (m)")

# 2. Add the transformed points on top
plot(st_geometry(lupus_bc_transformed),
     pch = 19,               # Point character (19 is a solid circle)
     col = "red",            # Color of the points
     cex = 0.7,              # Size of the points
     add = TRUE)             # *** Crucial: Add to the existing plot ***

# Optional: Add a legend
legend("topright", legend = "Lupus Occurrence", pch = 19, col = "red", pt.cex = 0.7)
```

```{r}
# --- Ensure both objects are sf objects ---
# lupus_bc_transformed is already sf

# Convert DATA$Window (sp object) to an sf object
window_sf <- st_as_sf(DATA$Window)

# --- Check CRSs match (Important!) ---
print(paste("CRSs match:", identical(st_crs(window_sf), st_crs(lupus_bc_transformed))))


# --- Plotting with ggplot2 ---
ggplot() +
  # Add the window polygon layer first (bottom layer)
  geom_sf(data = window_sf,
          fill = "grey85",
          color = "grey40") +

  # Add the points layer on top
  geom_sf(data = lupus_bc_transformed,
          color = "red",
          shape = 19,      # Shape (19 is solid circle)
          size = 1.5) +    # Size

  # Customize the plot appearance
  ggtitle("Lupus Occurrences in Study Window") +
  xlab("Easting (m)") + # Adjust axis labels if needed
  ylab("Northing (m)") +
  theme_minimal() +      # Or theme_bw(), theme_classic(), etc.
  coord_sf(datum = st_crs(window_sf)) # Ensure correct coordinate system interpretation for axes/graticules
```

```{r}
library(rayshader)

# 1. Extract the matrix
elevation_matrix <- DATA$Elevation$v

# 2. Fill NA values (optional but recommended)
# Here I replace NAs with the median elevation value
median_value <- median(elevation_matrix, na.rm = TRUE)
elevation_matrix[is.na(elevation_matrix)] <- median_value


elevation_matrix %>%
  sphere_shade(texture = "imhof1") %>%
  add_water(detect_water(elevation_matrix), color = "imhof1") %>%
  add_shadow(ray_shade(elevation_matrix, zscale = 3), 0.5) %>%
  add_shadow(ambient_shade(elevation_matrix), 0) %>%
  plot_3d(elevation_matrix, zscale = 10, fov = 0, theta = 135, zoom = 0.75, phi = 45, windowsize = c(1000, 800))


#render_snapshot() Static Image

# 4. Allow interaction
rgl::rglwidget()
```




```{r}
# Assuming your objects are like this:
# my_list$Window     (spatial boundary)
# my_list$Elevation  (raster)

# Step 1: Convert Elevation raster to a data.frame
elevation_df <- as.data.frame(DATA$Elevation, xy = TRUE)

# The column with elevation values might be named after the raster layer
colnames(elevation_df)
# If needed, rename it for easier handling:
names(elevation_df)[3] <- "elevation"

# Step 2: Make sure Window is an sf object
window_sf <- st_as_sf(DATA$Window)

# Step 3: Plot with ggplot2
ggplot() +
  geom_raster(data = elevation_df, aes(x = x, y = y, fill = elevation)) +
  geom_sf(data = window_sf, fill = NA, color = "black") + # Window outline
  scale_fill_viridis_c(option = "C") + # Nice color scale for elevation
  coord_sf() +
  theme_minimal()
```

```{r}
library(rayshader)

# Step 3: Plot with ggplot2
p <- ggplot() +
  geom_raster(data = elevation_df, aes(x = x, y = y, fill = elevation)) +
  geom_sf(data = window_sf, fill = NA, color = "black") + # Window outline
  scale_fill_viridis_c(option = "C") + # Nice color scale for elevation
  coord_sf() +
  labs(title= "BC Elevation") +
  theme(
    plot.background = element_rect(
      fill = "white",
      colour = "white"
    )
  )

# 2. Render in 3D
plot_gg(p, 
        multicore = TRUE,  # faster if you have multiple cores
        width = 5, 
        height = 5, 
        scale = 300,       # how "tall" the elevation looks
        zoom = 0.7, 
        phi = 45, 
        theta = 135
        )

# 3. Optional: make it interactive
rgl::rglwidget()
```


```{r}
# Extract the Window object
Window <- DATA$Window

# Extract coordinates from sf object
coords <- st_coordinates(lupus_bc_transformed)

# Define window (already projected)
bc_window <-  as.owin(st_as_sf(Window))

# Create ppp
lupus_ppp <- ppp(x = coords[, 1],
                 y = coords[, 2],
                 window = bc_window)

# Check it
plot(lupus_ppp, main = "Wolf Sightings (ppp)")
```

```{r}
# Check which points are inside the window
inside_window <- inside.owin(coords[, 1], coords[, 2], bc_window)

# Subset the coordinates to only include points inside the window
coords_inside <- coords[inside_window, ]

# Remove duplicates
coords_inside <- unique(coords_inside)

# Create ppp object with filtered coordinates
lupus_ppp <- ppp(x = coords_inside[, 1],  # X (Eastings)
                 y = coords_inside[, 2],  # Y (Northings)
                 window = bc_window)  # Study region window

# Check the ppp object
plot(lupus_ppp, main = "Wolf Sightings (ppp)")

```

```{r}
#Split into a 10 by 10 quadrat and count points
Q <- quadratcount(lupus_ppp,
                  nx = 2,
                  ny = 2)

#Plot the output 
plot(lupus_ppp,
     pch = 16,
     cex = 0.5,
     cols = "#046C9A",
     main = "Quadrat Test Results")

plot(Q, cex = 2, col = "red", add = T)
```



```{r}
#Quadrat test of homogeneity 
quadrat.test(quadratcount(lupus_ppp,
                  nx = 2,
                  ny = 2))
```

```{r}
#Density estimation of lambda(u)
lambda_u_hat <- density(lupus_ppp)

#Plot the output Note the use of image = TRUE
plot(lambda_u_hat,
     main = "Kernel estimate of Canis Lupus intensity")

plot(lupus_ppp,
     pch = 16,
     cex = 0.6,
     cols = "white",
     add = T)
```


```{r}

window <-as.owin(st_as_sf(DATA$Window))
# Estimate R
R <- bw.ppl(lupus_ppp)

#Calculate test statistic
LR <- scanLRTS(lupus_ppp, r = R)

#Plot the output 
plot(LR,
     main = "hotspot analysis for canis lupus")

plot(window, add = TRUE, border = "white", lwd = 2)
```


```{r}
#Compute local p-values
pvals <- eval.im(pchisq(LR,
                        df = 1,
                        lower.tail = FALSE))


#Plot the output
plot(pvals, main = "Local p-values")
```


```{r}
#Estimate the empirical k-function
k_bei <- Kest(lupus_ppp)

#Display the object
k_bei

#visualise the results
plot(k_bei,
     main = "Ripley's K-function",
     lwd = 2)
```
**Blue Line:** This represents the theoretical K-function under Complete Spatial Randomness (CSR). For a Poission process. this line serves as the baseline for comparision.

**Black Line():** this is the estimated K-function for ```lupus_ppp``` data using the isotropic edge correction.

**pink Dashed Line:** This is the estimated K-function for ```lupus_ppp``` data using the translational edge correction.

**Green Line:** this is the estimated K-function for ```lupus_ppp``` data using the border method edge correction.


**Interpreting The Plot:**

- Small Distances (Low r) : All the estimated K-functions (black, pink, and green lines) start close or slightly above the blue line at very small distances. This might suggest a slight tendency for clustering at very small scales.

- Intermediate Distances(Medium r) : As the distance **r** increases, the black lines rise considerably **above** the blue line. This indicates **significant clustering** in the ```lupus_ppp``` point pattern at these intermediate distances (roughly from the beginning up tto around 300,000 on the x-axis). the green line also goes the blue line, supporting clustering, but to a lesser extent at larger distances.

- Large Distances (High r) : At the largest distances shown, the black line and pink lines remain well **above** the blue line, suggesting that the clustering persists at larger scales. The green line appears to flattenout at the higher end of the distance range.

**In summary:**

The ```lupus_ppp``` point pattern shows evidence of **significant spatial clustering** over a wide range of distances. The estimated number of neighboring points within a given radius is consistently higher than what would be expected under a completely random distribution.

```{r}
# Bootstrapped CIs
# rank = 1 means the max and min
# Border correction is to correct for edges around the window
# values will be used for CI
E_bei <- envelope(lupus_ppp,
                  Kest,
                  correction="border",
                  rank = 1,
                  nsim = 19,
                  fix.n = T)

# visualise the results
plot(E_bei,
     main = "Ripley's K-function with Envelopes",
     lwd = 2)


#Estimate intensity
lambda_canis_lupus <- density(lupus_ppp, bw.ppl)

Kinhom_canis_lupus <- Kinhom(lupus_ppp, lambda_canis_lupus)

Kinhom_canis_lupus

# visualise the results
plot(Kinhom_canis_lupus,
     theo ~ r,
     main = "",
     col = "grey70",
     lty = "dashed",
     lwd = 2)

plot(Kinhom_canis_lupus,
     border ~ r,
     col = c("#046C9A"),
     lwd = 2,
     add = T)
```

**Interpretation**

- For small distances (up to roughly 50,000), the blue line is very close to the grey dashed line. This suggests that at these small scales, the observed pattern is consistent with an inhomogeneous Poisson process. The estimated intensity explains the spatial pattern at this local level.

- For distances greater than approximately 50,000, the blue line consistently rises above the grey dashed line. This indicates clustering in the wolf point pattern at these intermediate and larger spatial scales that is not explained by the spatial variation in intensity alone.

```{r}
# Estimate the g function
pcf_canis_lupus <- pcf(lupus_ppp)

pcf_canis_lupus

# Default plot method
plot(pcf_canis_lupus)

# visualise the results
plot(pcf_canis_lupus,
     theo ~ r,
     ylim = c(0,20),
     main = "",
     col = "grey70",
     lwd = 2,
     lty = "dashed")

plot(pcf_canis_lupus,
     iso ~ r,
     col = c("#046C9A"),
     lwd = 2,
     add = T)
```
- **Very Small Distances (r close to 0):** Both the black and pink lines show a very tall peak that goes far above 1. This indicates very strong clustering at very short distances. Wolves are highly likely to be found in close proximity to other wolves.

- **Intermediate Distances (roughly 20,000 to 50,000 on the x-axis):** After the initial peak, both estimated PCF lines drop below 1. This suggests a zone of regularity or inhibition at these distances. There are fewer pairs of wolves at these separations than expected under CSR. This could imply some spacing or avoidance after the initial close-range clustering.


- **Larger Distances (beyond approximately 80,000 on the x-axis):** For distances greater than around 80,000, both the black and pink lines generally stay close to the green dotted line at 1. This suggests that at these larger scales, the spatial pattern is largely consistent with Complete Spatial Randomness. The strong short-range interactions do not extend to these broader scales.




```{r}
# Estimate the homogeneous pair correlation function with simulation envelopes
set.seed(123) # Set seed for reproducibility
g_hom <- envelope(lupus_ppp, fun = pcf, nsim = 19)

# Plot homogeneous pair correlation function
plot(g_hom, main = "Homogeneous Pair Correlation Function", 
     xlim = c(0, max(g_hom$r)), legend = TRUE)
```
- **Very Small Distances (r close to 0):** The black line shoots up to a very high value and goes far **above the upper boundary of the grey simulation envelope**. This indicates **statistically significant clustering** at very short distances. The wolves are significantly more aggregated at fine scales than expected under CSR.

- **Intermediate Distances (approximately 20,000 to 80,000 on the x-axis):** After the initial peak, the black line drops sharply and goes **below the lower boundary of the grey simulation envelope**. It stays below the lower envelope for a considerable range of distances. This indicates **statistically significant regularity or inhibition** at these intermediate distances. The wolves are significantly more spread out at these separations than expected under CSR.

- **Larger Distances (beyond approximately 80,000):** The black line fluctuates and appears to return to within the grey simulation envelope at larger distances. This suggests that at these scales, the observed spatial pattern is **not statistically significantly different from Complete Spatial Randomness**.

```{r}
# Estimate the inhomogeneous pair correlation function with simulation envelopes
set.seed(123) # Set seed for reproducibility
g_inhom <- envelope(lupus_ppp, fun = pcfinhom, nsim = 19, simulate = expression(rpoispp(density.ppp(lupus_ppp))))

plot(g_inhom, main = "Inhomogeneous Pair Correlation Function", 
     xlim = c(0, max(g_inhom$r)), legend = TRUE)
```
- **Very Small Distances (r close to 0):** The black line shows a very tall peak that goes far **above the upper boundary of the grey simulation envelope**. This indicates **statistically significant clustering** at very short distances, **even after accounting for the estimated spatial variation in intensity**. The wolves are significantly more aggregated at fine scales than expected based on the estimated density surface alone.

Intermediate Distances (approximately 20,000 onwards): After the initial strong peak, the black line drops sharply. For distances greater than approximately 20,000, the black line appears to fall **within or very close to the boundaries of the grey simulation envelope.**

```{r}
elev = DATA$Elevation
forest_cover = DATA$Forest
hfi = DATA$HFI
dis_water = DATA$Dist_Water
```


```{r}
#Estimate Rho for elevation
rho_elev <- rhohat(lupus_ppp,elev)

plot(rho_elev,
     main = "Intensity of canis_lupus as a Function of Elevation",
     xlab = "Elevation (m)")
```
- The plot shows a very high estimated intensity of wolves at very low elevations (close to 0 meters).

- As the elevation increases, the estimated intensity drops sharply and quickly approaches zero.
  
- For most of the elevation range (above a few hundred meters), the estimated intensity is very -  low, suggesting that wolves are much less likely to be found at higher elevations in your study area.

In summary, the plot suggests that the intensity (density) of wolves in our study area is strongly associated with elevation:

- Wolves are highly concentrated at very low elevations.
- Their density drops dramatically as elevation increases.
- At higher elevations, the density of wolves is very low.
```{r}
#Estimate Rho for forest
rho_forest <- rhohat(lupus_ppp, forest_cover)

plot(rho_forest,
     main = "Intensity of canis_lupus as a Function of Forest",
     xlab = "Forest Cover")
```
- The plot shows a relatively low estimated intensity of wolves when forest cover is very low (close to 0%).

- As forest cover increases, the estimated intensity generally increases, reaching a peak around 60-70% forest cover.

- Beyond this peak, as forest cover approaches 100%, the estimated intensity appears to decrease slightly.

In summary, the plot suggests the following about the relationship between wolf intensity and forest cover in our study area:

- Wolves appear to prefer areas with moderate to high forest cover (around 60-70%), as the estimated intensity is highest in this range.

- The intensity is lower in areas with very low forest cover.

- There might be a slight decrease in intensity in areas with very high (almost 100%) forest cover, although this part of the trend has a wider confidence interval, suggesting more uncertainty.

- Overall, forest cover seems to be an important factor influencing the spatial distribution of wolves in our study area.
```{r}
#Estimate Rho for hfi
rho_hfi <- rhohat(lupus_ppp,hfi)

plot(rho_hfi,
     main = "Intensity of canis_lupus as a Function of HFI",
     xlab = "HFI")
```

- The plot shows a very low estimated intensity of wolves when the HFI is very low (close to 0).

- As the HFI increases from 0 to around 0.4, the estimated intensity gradually increases.

- Between an HFI of approximately 0.4 and 0.6, the estimated intensity appears to plateau or slightly decrease.

- Beyond an HFI of around 0.6, the estimated intensity shows a more substantial increase, peaking around an HFI of 0.8 to 0.9.

- For the highest HFI values (close to 1.0), the intensity seems to drop off again, although the confidence interval is quite wide in this region.


In summary, the plot suggests the following about the relationship between wolf intensity and the Human Footprint Index in our study area:

- Wolves appear to have a low density in areas with very low human influence (low HFI).

- The density tends to increase with increasing human influence up to a certain point (around HFI 0.6).

- Interestingly, the highest estimated densities are observed at relatively high HFI values (around 0.8-0.9), suggesting that wolves might be utilizing areas with significant human influence to some extent. However, the wide confidence interval in this region indicates this finding should be interpreted with caution.

- The density appears to decrease again in areas with the highest levels of human impact.
```{r}
#Estimate Rho for dis_water
rho_dist_water <- rhohat(lupus_ppp, dis_water)

plot(rho_dist_water,
     main = "Intensity of canis_lupus as a Function of Distance_to_Water",
     xlab = "Dist Water")
```

- The plot shows a relatively low estimated intensity of wolves at very close distances to water (distance close to 0).

- As the distance to water increases slightly, the estimated intensity appears to increase, showing a peak around a distance of roughly 2,000 to 3,000 units.

- The intensity then decreases and fluctuates at lower levels between distances of approximately 3,000 and 8,000.

- There is a prominent peak in estimated intensity at a distance of around 9,000 to 10,000 units from water. This suggests a higher likelihood of finding wolves at this particular distance.

- Beyond a distance of around 12,000 units, the estimated intensity drops to a very low level and stays close to zero for the rest of the plotted range.

In summary, the plot suggests the following about the relationship between wolf intensity and distance to water in our study area:

- Wolves do not appear to have the highest density very close to water sources.

- There are peaks in wolf intensity at certain distances from water, notably around 2,000-3,000 units and a more prominent peak around 9,000-10,000 units.

- The density of wolves is very low at distances greater than approximately 12,000 units from water.

- The relationship between wolf intensity and distance to water is complex and non-linear, with preferences for certain intermediate distances.

```{r}
#Fit the PPP model
fit <- ppm(lupus_ppp ~ elev + I(forest_cover^2) + hfi + dis_water)

fit
```


```{r}
#Calculate the partial residuals as a function of elevation
par_res_elev <- parres(fit, "elev")

#Calculate the relative intensity as a function of cover
par_res_cover <- parres(fit, "forest_cover")

#Calculate the partial residuals as a function of elevation
par_res_hfi <- parres(fit, "hfi")

#Calculate the relative intensity as a function of cover
par_res_dist_water <- parres(fit, "dis_water")

#Side by side plotting
plot(par_res_elev,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Elevation (m)")
plot(par_res_cover,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Forest Cover")
plot(par_res_hfi,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "HFI")
plot(par_res_dist_water,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Water Distance")
```

```{r}
# NA with mean Forest Cover
mean_forest_cover <- mean(as.vector(as.matrix(forest_cover)), na.rm = TRUE)
forest_cover_clean <- eval.im(ifelse(is.na(forest_cover), mean_forest_cover, forest_cover))
# model
forest_cover_model <- ppm(lupus_ppp, ~ forest_cover, covariates = list(forest_cover = forest_cover_clean))

print(forest_cover_model)

```

```{r}
forest_cover_residuals <- residuals(forest_cover_model, type = "pearson")
forest_cover_residuals$v[!is.finite(forest_cover_residuals$v)] <- NA
plot(forest_cover_residuals, 
     main = "Residuals - forest_cover Model", 
     na.col = "transparent")
```

```{r}
# NA with mean elevation
mean_elev <- mean(as.vector(as.matrix(elev)), na.rm = TRUE)
elev_clean <- eval.im(ifelse(is.na(elev), mean_elev, elev))
# model
elevation_model <- ppm(lupus_ppp, ~ elev, covariates = list(elev = elev_clean))
print(elevation_model)
```


```{r}
Elevation_residuals <- residuals(elevation_model, type = "pearson")
Elevation_residuals$v[!is.finite(Elevation_residuals$v)] <- NA
plot(Elevation_residuals, 
     main = "Residuals - Elevation Model", 
     na.col = "transparent")
```

```{r}
# NA with mean hfi
mean_hfi <- mean(as.vector(as.matrix(hfi)), na.rm = TRUE)
hfi_clean <- eval.im(ifelse(is.na(hfi), mean_hfi, hfi))
# model
hfi_model <- ppm(lupus_ppp, ~ hfi, covariates = list(hfi = hfi_clean))
print(elevation_model)
```

```{r}
hfi_residuals <- residuals(hfi_model, type = "pearson")
hfi_residuals$v[!is.finite(hfi_residuals$v)] <- NA
plot(hfi_residuals, 
     main = "Residuals - hfi Model", 
     na.col = "transparent")
```


```{r}
# NA with mean Forest Cover
mean_forest_cover <- mean(as.vector(as.matrix(forest_cover)), na.rm = TRUE)
forest_cover_clean <- eval.im(ifelse(is.na(forest_cover), mean_forest_cover, forest_cover))

# NA with mean elevation
mean_elev <- mean(as.vector(as.matrix(elev)), na.rm = TRUE)
elev_clean <- eval.im(ifelse(is.na(elev), mean_elev, elev))

# NA with mean HFI
mean_hfi <- mean(as.vector(as.matrix(hfi)), na.rm = TRUE)
hfi_clean <- eval.im(ifelse(is.na(hfi), mean_hfi, hfi))

# NA with mean Dis_Water
mean_dis_water <- mean(as.vector(as.matrix(dis_water)), na.rm = TRUE)
dis_water_clean <- eval.im(ifelse(is.na(dis_water), mean_dis_water, dis_water))
```


```{r}
clean_fit <- ppm(lupus_ppp ~ elev + I(forest_cover^2) + hfi + dis_water,
           data = list(elev = elev_clean,
                       forest_cover = forest_cover_clean,
                       hfi = hfi_clean,
                       dis_water = dis_water_clean))
clean_fit
```


```{r}
#Calculate the partial residuals as a function of elevation
par_res_elev <- parres(clean_fit, "elev")

#Calculate the relative intensity as a function of cover
par_res_cover <- parres(clean_fit, "forest_cover")

#Calculate the partial residuals as a function of elevation
par_res_hfi <- parres(clean_fit, "hfi")

#Calculate the relative intensity as a function of cover
par_res_dist_water <- parres(clean_fit, "dis_water")

#Side by side plotting
plot(par_res_elev,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Elevation (m)")
plot(par_res_cover,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Forest Cover")
plot(par_res_hfi,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "HFI")
plot(par_res_dist_water,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Water Distance")

```

```{r}
residual_fit_clean = residuals(clean_fit, "pearson")

plot(residual_fit_clean, main = "clean model Residual")

#Plot the model predictions
plot(clean_fit,
     se = FALSE,
     superimpose = FALSE)
#Overlay the B. pendula locations
plot(lupus_ppp,
     pch = 16,
     cex = 0.6,
     cols = "white",
     add = TRUE)
```

- The Pearson residual plot indicates that while fitted PPM model captures some of the factors influencing wolf distribution, there is **remaining unexplained spatial variation**, particularly in areas where the model is over-predicting wolf occurrences (the regions with negative residuals). This suggests that we might consider exploring additional covariates or model structures to improve the fit and better explain the spatial patterns of wolves in these specific areas. A perfectly fitted model would ideally show residuals that are spatially random.

- The fitted model (clean_fit) suggests that the combination of environmental conditions most suitable for lupus_ppp  are relatively rare and geographically concentrated in small areas in the southwest. The model predicts much lower suitability across most of the landscape. The fact that many observed points fall in areas predicted to have low intensity might indicate that the model isn't perfectly capturing all factors influencing the distribution, potentially leading to underprediction in those specific spots.



```{r}
library(splines)

#Fit the PPP model
fit_spline_clean <- ppm(lupus_ppp ~ bs(elev, 7) + bs(forest_cover, 8) + bs(hfi, 9) + bs(dis_water, 8), data = list(elev = elev_clean, forest_cover = forest_cover_clean, hfi = hfi_clean, dis_water = dis_water_clean))


fit_spline_clean
```


```{r}
#Calculate the partial residuals as a function of elevation
par_res_elev <- parres(fit_spline_clean, "elev")

#Calculate the relative intensity as a function of cover
par_res_cover <- parres(fit_spline_clean, "forest_cover")

#Calculate the partial residuals as a function of elevation
par_res_hfi <- parres(fit_spline_clean, "hfi")

#Calculate the relative intensity as a function of cover
par_res_dist_water <- parres(fit_spline_clean, "dis_water")

#Side by side plotting
plot(par_res_elev,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Elevation (m)")
plot(par_res_cover,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Forest Cover")
plot(par_res_hfi,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "HFI")
plot(par_res_dist_water,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Water Distance")

```

```{r}
residual_fit_spline_clean = residuals(fit_spline_clean, "pearson")

plot(residual_fit_spline_clean, main = "clean spline model Residual")

#Plot the model predictions
plot(fit_spline_clean,
     se = FALSE,
     superimpose = FALSE)

#Overlay the B. pendula locations
plot(lupus_ppp,
     pch = 16,
     cex = 0.6,
     cols = "white",
     add = TRUE)
```
**Striking Similarity:**
The overall spatial pattern of residuals is remarkably similar to the previous model's ("clean model Residual").

**Interior:**
Much of the interior remains yellow/orange, indicating residuals close to zero. The spline model, like the simpler model, fits reasonably well here.

**Coast & Southeast:**
These areas are still predominantly magenta/purple, indicating significant overprediction by the model. The slightly more negative values on the color scale suggest the overprediction might even be slightly more pronounced in some spots according to this model.

**Circles (Raw Residuals):**
Similar pattern to before, with large circles (large magnitude raw residuals) concentrated in the southeast, but also some noticeable ones in the interior, suggesting localized deviations.


```{r}
anova(clean_fit, fit_spline_clean, test = "LRT")
```
- The Likelihood Ratio Test strongly suggests that the relationships between the intensity of wolf occurrences and  covariates (elevation, forest cover, HFI, and distance to water) are likely **non-linear**. Using flexible functions like splines in our model is more appropriate for capturing these complex relationships than using simple linear terms

```{r}
# Apply log transformation to dis_water
dis_water_log <- log(dis_water_clean + 1)

hfi_log <- log(hfi_clean + 1)

# Fit the model with log-transformed dis_water
fit_log_with_spline_clean<- ppm(lupus_ppp ~ bs(elev, 7) + bs(forest_cover, 8) + bs(hfi_log, df = 5) + bs(dis_water_log, df = 6), data = list(elev = elev_clean, forest_cover = forest_cover_clean, hfi = hfi_log, dis_water = dis_water_log))

fit_log_with_spline_clean
```



```{r}
#Calculate the partial residuals as a function of elevation
par_res_elev <- parres(fit_log_with_spline_clean, "elev")

#Calculate the relative intensity as a function of cover
par_res_cover <- parres(fit_log_with_spline_clean, "forest_cover")

#Calculate the partial residuals as a function of elevation
par_res_hfi <- parres(fit_log_with_spline_clean, "hfi_log")

#Calculate the relative intensity as a function of cover
par_res_dist_water <- parres(fit_log_with_spline_clean, "dis_water_log")

#Side by side plotting
plot(par_res_elev,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Elevation (m)")
plot(par_res_cover,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Forest Cover")
plot(par_res_hfi,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "HFI")
plot(par_res_dist_water,
     legend = FALSE,
     lwd = 2,
     main = "",
     xlab = "Water Distance")
```


```{r}
residual_fit_spline_log_clean = residuals(fit_log_with_spline_clean, "pearson")

plot(residual_fit_spline_log_clean, main = "clean spline log model Residual")

#Plot the model predictions
plot(fit_log_with_spline_clean,
     se = FALSE,
     superimpose = FALSE)

#Overlay the B. pendula locations
plot(lupus_ppp,
     pch = 16,
     cex = 0.6,
     cols = "white",
     add = TRUE)
```
**Comparison to Previous Spline Model:**
The most striking observation is how incredibly similar this residual plot looks to the previous one ("clean spline model Residual") that didn't use the log transformations for hfi and dis_water.

**Spatial Pattern:**
The locations of the yellow/orange areas (good fit) and the magenta/purple areas (overprediction) are virtually unchanged. Strong negative residuals persist along the coast and in the southeast corner.

**Circles:** The pattern and relative sizes of the circles representing raw residuals also appear unchanged.


**Predominantly Low Intensity:** 
Similar to the trend plot from the simpler ```clean_fit model```, the vast majority of the study area is dark blue/purple. The model predicts a very low probability of point occurrence across most of the landscape.

**Localized Hotspots:** 
Small areas, primarily concentrated in the southwest (coastal/border region), show higher predicted intensities (magenta/yellow). These are where the model identifies the most favorable conditions based on the specific covariate values and the fitted spline relationships.


**Observed Data (White Dots):**
The overlay shows that while some points fall near the predicted higher-intensity areas, many points are located within the extensive dark blue regions where the model predicts very low intensity.



**Overall Conclusion:**
- Using splines and log transformations for some covariates did not fundamentally change the model's overall prediction of the spatial trend compared to the simpler model.

- The model consistently predicts that the conditions suitable for lupus_ppp points are rare and concentrated in small areas (primarily southwest).

- It predicts very low suitability across most of the region.

- The discrepancy between the predicted low intensity and the presence of observed points in large parts of the interior persists.

**Connecting to the Residual Plot:**
This fitted trend plot is consistent with the corresponding "clean spline log model Residual" plot.

- The trend plot shows low predicted intensity along the coast and in the southeast. The residual plot showed strong negative residuals there, meaning even this low predicted intensity was still an overprediction compared to reality.

- The trend plot shows low predicted intensity in the interior. The residual plot showed residuals closer to zero there, indicating a better match (predicted low intensity aligns with observed low density).

In essence, making the model more flexible with splines and applying log transformations didn't resolve the core issues identified earlier. The model still struggles to accurately capture the distribution, particularly in the areas where it significantly overpredicts (coast/SE).


```{r}
anova(fit_log_with_spline_clean, fit_spline_clean, test = "LRT")
``` 
**Conclusion:**
- The p-value (0.9293) is very large (much larger than typical significance levels like 0.05).
Therefore, **we fail to reject the null hypothesis**.

- This means there is **no statistically significant evidence** to suggest that Model 2 (splines on original ```hfi```/```dis_water``` with higher df) fits the data significantly better than Model 1 (splines on log-transformed ```hfi```/```dis_water``` with lower df).

- Log-transforming ```hfi``` and ```dis_water``` (and adjusting the spline complexity slightly) did **not** result in a significantly worse fit compared to using splines on the original scales with higher complexity. Neither model is statistically superior to the other based on this test.

Consistency with Visual Checks: This statistical result perfectly aligns with our visual comparison of the residual plots for``` fit_spline_clean``` and ```fit_log_with_spline_clean```. The plots looked almost identical, indicating that neither model formulation offered a clear advantage in explaining the spatial patterns or reducing the problematic residuals in the coastal and southeastern areas. The ANOVA provides statistical backing for this visual observation.


```{r}
library(ape)
library(fields)
library(gstat)
```

```{r}
coords <- cbind(lupus_ppp$x, lupus_ppp$y)

elev_values <- elev_clean[lupus_ppp]


dist_mat <- fields::rdist(coords)

# Inverse distance weights (avoid division by zero)
#inv_dist <- 1 / dist_mat

#diag(inv_dist) <- 0  # set self-distances to 0 (avoid Inf)


ape::Moran.I(elev_values, weight = dist_mat)

```

```{r}
# Extract coordinates from lupus_ppp
coords <- coords(lupus_ppp)

# Extract elevation values at those locations
elev_values <- elev_clean[lupus_ppp]

# Combine into a data frame
DATA <- data.frame(Z_s = elev_values,
                   x = coords[,1],
                   y = coords[,2])

# Convert to SpatialPointsDataFrame
sp::coordinates(DATA) <- ~x+y

# Calculate empirical variogram
vg <- gstat :: variogram (Z_s ~ 1, data = DATA )
# object of class = " gstatVariogram "
plot ( vg )
```

```{r}
# Fit linear correlation model
fit.linear <- fit.variogram (vg , vgm ("Lin"))
fit.linear
# Plot the empirical and fitted variogram
plot(vg, fit.linear, main = "Fitted Linear Variogram")
```

```{r}
fit.spherical <- fit.variogram(vg, vgm("Sph"))
fit.spherical
plot(vg, fit.spherical, main = "Fitted spherical Variogram")
```

```{r}
# Fit Gaussian correlation model
fit.Gaussian <- fit.variogram (vg , vgm ("Gau"))
fit.Gaussian
plot(vg, fit.Gaussian, main = "Fitted Gaussian Variogram")
```

```{r}
# Fit exponential correlation model
fit.exponential <- fit.variogram (vg , vgm ("Exp"))
fit.exponential
plot(vg, fit.exponential, main = "Fitted exponential Variogram")
```


```{r}
# Fit nugget only model
fit.nugget <- fit.variogram (vg , vgm ("Nug"))
fit.nugget
plot(vg, fit.nugget, main = "Fitted nugget Variogram")
```

```{r}
# Initialize list to store results
model_list <- list(
  spherical = fit.spherical,
  linear = fit.linear,
  Gaussian = fit.Gaussian,
  exponential = fit.exponential,
  nugget = fit.nugget
)

# Extract SSErr safely
model_names <- c()
sse_values <- c()

for (name in names(model_list)) {
  fit <- model_list[[name]]
  sse <- tryCatch(attr(fit, "SSErr"), error = function(e) NA)
  
  if (!is.null(sse) && !is.na(sse)) {
    model_names <- c(model_names, name)
    sse_values <- c(sse_values, sse)
  }
}

# Create and order results
results <- data.frame(model = model_names, SSErr = sse_values)
results <- results[order(results$SSErr), ]

# Print
print(results)
```

```{r}
# Get fitted values from the linear variogram model
fitted <- variogramLine(fit.linear,
                        maxdist = max(vg$dist),
                        dist_vector = vg$dist)

# Calculate residuals
residuals <- fitted$gamma - vg$gamma

# Visualize the residuals
plot(residuals ~ fitted$gamma,
     main = "Residuals vs Fitted (Linear Variogram)",
     xlab = "Fitted γ",
     ylab = "Residuals",
     pch = 19,
     col = "#046C9A")
abline(h = 0, lty = 2, col = "gray")

```

